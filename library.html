<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Library | Nick Tagliamonte</title>
    <meta
      name="description"
      content="Learn more about Nick Tagliamonte, a Computer Science student with a passion for software development, data optimization, and web development."
    />
    <meta
      name="keywords"
      content="Nick Tagliamonte, about me, computer science, software development, personal interests, skills"
    />
    <link rel="stylesheet" href="css/styles.css" />
    <link
      rel="stylesheet"
      href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css"
    />
  </head>

  <body>
    <!-- Header Section -->
    <header role="banner">
      <div class="header-left">
        <h1 role="heading" aria-level="1" class="home-link">
          <a href="index.html">Nick Tagliamonte</a>
        </h1>
      </div>
      <div class="dark-mode-toggle">
        <span class="sun-icon" role="img" aria-label="Sun">&#9728;</span>
        <label class="toggle">
          <input type="checkbox" id="darkModeToggle" />
          <span class="slider"></span>
        </label>
      </div>
      <nav class="navigation" role="navigation" aria-label="Main Navigation">
        <ul>
          <li><a href="about.html" aria-current="page">About</a></li>
          <li><a href="projects.html">Projects</a></li>
          <li><a href="resume.html">Resume</a></li>
          <li><a href="contact.html">Contact</a></li>
          <li><a href="personal.html">Personal</a></li>
          <li><a href="information.html" role="link">Information</a></li>
        </ul>
      </nav>
      <!-- Hamburger Menu Icon - only visible on screens smaller than 768px -->
      <div
        id="mobile-menu-icon"
        class="hamburger-menu"
        aria-label="Open Navigation Menu"
      >
        <span></span>
        <span></span>
        <span></span>
      </div>
      <div id="overlay-menu">
        <nav
          class="overlay-navigation"
          role="navigation"
          aria-label="Mobile Navigation"
        >
          <ul>
            <li><a href="index.html">Home</a></li>
            <li><a href="about.html">About</a></li>
            <li><a href="projects.html">Projects</a></li>
            <li><a href="resume.html">Resume</a></li>
            <li><a href="contact.html">Contact</a></li>
            <li><a href="personal.html">Personal</a></li>
            <li><a href="information.html" role="link">Information</a></li>
          </ul>
          <!-- Dark mode toggle at the bottom -->
          <div class="overlay-dark-mode-toggle">
            <button
              class="overlay-sun-icon"
              role="img"
              aria-label="Sun"
              id="overlayDarkModeToggle"
            >
              &#9728;
            </button>
            <label class="overlay-toggle">
              <input type="checkbox" />
              <span class="slider"></span>
            </label>
          </div>
        </nav>
      </div>
    </header>

    <!-- Main Content Section -->
    <main role="main" class="about-container">
      <section class="left-content">
        <!-- Article Section -->
        <section id="information">
          <h2>Project Name: Data Structure Library</h2>
          <hr />
          <h3>Overview</h3>
          <p>
            <span style="display: inline-block; width: 2em"></span>
            A library implementing common (and some uncommon but interesting)
            data structures in java. The idea here is largely to drill data
            structures in a way that will hopefully improve performance in
            technical interviews, in addition to testing with JUnit, which is a
            practice that I'm not going into this with any experience in. All of
            the higher level or more complex structures will be built using
            simpler structures that I create. For example, the hash table uses
            an instance of my DynamicArray class to store entries.
          </p>
          <h3>List of Structures to be Implemented</h3>
          <ol>
            <li>Linear [Complete]</li>
            <ol>
              <li>Dynamic array</li>
              <li>
                Doubly linked list (optionally circular, optionally singly
                linked)
              </li>
              <li>Array based stack</li>
              <li>Linked list-based stack</li>
              <li>Array-based circular queue</li>
              <li>Deque</li>
            </ol>
            <li>Hashing [Complete]</li>
            <ol>
              <li>
                Open Addressing or Separate Chaining (differentiated with
                constructor arguments)
              </li>
            </ol>
            <li>Trees [Complete]</li>
            <ol>
              <li>Binary search tree</li>
              <li>AVL tree</li>
              <li>Red-black tree</li>
              <li>B-tree</li>
              <li>Standard trie</li>
              <li>Compressed (radix) trie</li>
            </ol>
            <li>Heaps [In Progress]</li>
            <ol>
              <li>Min heap</li>
              <li>Max heap</li>
              <li>Fibonacci heap</li>
            </ol>
            <li>Graphs</li>
            <ol>
              <li>Adjacency list</li>
              <li>Adjacency matrix</li>
              <li>BFS and DFS graph traversal (probably methods)</li>
              <li>Disjoint set</li>
            </ol>
            <li>Advanced</li>
            <ol>
              <li>Skip list</li>
              <li>Bloom filter</li>
              <li>Fenwick tree</li>
              <li>Segment tree</li>
              <li>Suffix tree</li>
            </ol>
          </ol>

          <h3>Linear</h3>
          <p>
            <span style="display: inline-block; width: 2em"></span>
            Major questions that came up during the creation of the linear data
            structures were:
          </p>
          <ul>
            <li>Generics: Using <code>Object[]</code> or <code>T[]</code></li>
            <ul>
              <li>
                I went with <code>Object[]</code> to avoid excessive
                <code>SuppressWarning(“unchecked”)</code> flags.
              </li>
            </ul>
            <li>
              Testing: My LinkedList test class was failing one test because of
              an issue which I resolved. The reason wound up being a deleted
              class file, the result of which was the test being run on an old
              version of the LinkedList class.
            </li>
            <li>Array or LinkedList based Deque.</li>
            <ul>
              <li>
                Without an actual use case for this library, there wasn't a
                clearly superior choice between these two. I went with
                LinkedList based on the idea that it was more conceptually
                complex and would therefore be a better fit for what is really
                just a portfolio project. The conceptual complexity had already
                been handled by the LinkedList class itself though, so the Deque
                turned out to be a wrapper over that LinkedList class which was
                very quick to create.
              </li>
            </ul>
          </ul>

          <h3>Hashing</h3>
          <h3>2/11/25</h3>
          <p>
            <span style="display: inline-block; width: 2em"></span> The first
            major change from my initial plan was to combine the Separate
            Chaining and Open Addressing implementations of a Hash Table into a
            single class which can differentiate between the two based on
            constructor arguments, but which creates just a simple linear
            probing hash table if nothing else is specified. <br /><br /><span
              style="display: inline-block; width: 2em"
            ></span>
            With the hash function, probing, and searching logic separated out
            to a utility HashFunctions file, the skeleton of this class came
            together quickly. A few put, delete, get, and clear methods. The
            biggest issue to manage was the array resizing logic in
            DynamicArray, which I built this on top of. I found myself having to
            independently track the resizing conditions in both this and the
            DynamicArray class, so that if the DynamicArray automatically
            resizes the hash table will rehash all its elements based on the new
            capacity. With that out of the way though, it was a fairly simple if
            verbose (because of the variety of options r/e collision resolution
            and probing).
          </p>

          <h3>Trees</h3>
          <p>
            <span style="display: inline-block; width: 2em"></span> The first
            time back after a long break during which time I sort of
            nonsensically decided to switch to Gentoo from Windows (really
            jumping into the deep end with that one), I finally have a commit
            with the first tree structure: BST.<br /><br /><span
              style="display: inline-block; width: 2em"
            ></span>
            The first few structures on the list, BST and AVL, were similar and
            more an exercise in writing recursive methods than anything else.
            Which was helpful at first but became repetitive after the 3rd or
            4th largely identical one. I question whether I could have
            centralized some of that logic into _TreeNode rather than hold it in
            all these separate methods themselves, but after thinking about it
            for a while I did not see an easy way into that: the things that the
            various methods were looking for and doing were both too direct and
            too disparate from one another for a clear abstraction of the
            process to come to mind for me. <br /><br />
            <span style="display: inline-block; width: 2em"></span>
            Red Black Trees represent a fairly significant departure from the
            previous two tree implementations. Initially I set out to model this
            after AVL, which was itself modeled after BST. Attempting to track
            parent pointers over comparable recursive methods made this a huge
            headache, so I switched to insertions and deletions being done
            iteratively instead. This did not come intuitively to me. I
            consulted reference material
            <strong>heavily</strong> through this part of the process and it was
            just not easy.
            <span style="display: inline-block; width: 2em"></span>
            BTrees were the hardest of the bunch, because of the merging of
            nodes. it's working, but only just, and I'm hoping that as I get
            practice with the different structures that require comparable logic
            it will get easier.
            <span style="display: inline-block; width: 2em"></span>
            Tries were the focus of the last few days. Standard Tries were very
            easy. came together quickly, no muss no fuss, and as a result I
            <strong>really</strong> padded out the functionality here. There are
            methods which have not been present in any other data structure, I
            had some time over spring break and was enjoying working with
            strings and prefixes. Radix Tries were harder, and that reads in the
            sparser methods written for them -- I got add and delete and search
            to work, and that's kind of fine for my purposes. There's something
            about the merge and split nodes process that I find very
            unintuitive. I ran into the same issue with BTree. I'm happy to say
            that based on that experience this one came together more quickly,
            but the difference is close to marginal. There are more coming up
            that will require operations which are more or less like this (in
            the short term, i'll be handling Fibonacci heaps by the end of the
            week. Longer term, I'm looking at things like suffix trees a month
            or two down the line). As a result, I am hoping that this becomes
            more intuitive as time goes on. We'll see.
          </p>
        </section>
      </section>
    </main>

    <!-- Footer Section -->
    <footer role="contentinfo">
      <p>&copy; 2024 Nick Tagliamonte</p>
    </footer>

    <script src="js/mobileNavigation.js"></script>
    <script src="js/darkMode.js"></script>
  </body>
</html>
