<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Library | Nick Tagliamonte</title>
    <meta
      name="description"
      content="Learn more about Nick Tagliamonte, a Computer Science student with a passion for software development, data optimization, and web development."
    />
    <meta
      name="keywords"
      content="Nick Tagliamonte, about me, computer science, software development, personal interests, skills"
    />
    <link rel="stylesheet" href="css/styles.css" />
    <link
      rel="stylesheet"
      href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css"
    />
  </head>

  <body>
    <!-- Header Section -->
    <header role="banner">
      <div class="header-left">
        <h1 role="heading" aria-level="1" class="home-link">
          <a href="index.html">Nick Tagliamonte</a>
        </h1>
      </div>
      <div class="dark-mode-toggle">
        <span class="sun-icon" role="img" aria-label="Sun">&#9728;</span>
        <label class="toggle">
          <input type="checkbox" id="darkModeToggle" />
          <span class="slider"></span>
        </label>
      </div>
      <nav class="navigation" role="navigation" aria-label="Main Navigation">
        <ul>
          <li><a href="about.html" aria-current="page">About</a></li>
          <li><a href="projects.html">Projects</a></li>
          <li><a href="resume.html">Resume</a></li>
          <li><a href="contact.html">Contact</a></li>
          <li><a href="personal.html">Personal</a></li>
          <li><a href="information.html" role="link">Information</a></li>
        </ul>
      </nav>
      <!-- Hamburger Menu Icon - only visible on screens smaller than 768px -->
      <div
        id="mobile-menu-icon"
        class="hamburger-menu"
        aria-label="Open Navigation Menu"
      >
        <span></span>
        <span></span>
        <span></span>
      </div>
      <div id="overlay-menu">
        <nav
          class="overlay-navigation"
          role="navigation"
          aria-label="Mobile Navigation"
        >
          <ul>
            <li><a href="index.html">Home</a></li>
            <li><a href="about.html">About</a></li>
            <li><a href="projects.html">Projects</a></li>
            <li><a href="resume.html">Resume</a></li>
            <li><a href="contact.html">Contact</a></li>
            <li><a href="personal.html">Personal</a></li>
            <li><a href="information.html" role="link">Information</a></li>
          </ul>
          <!-- Dark mode toggle at the bottom -->
          <div class="overlay-dark-mode-toggle">
            <button
              class="overlay-sun-icon"
              role="img"
              aria-label="Sun"
              id="overlayDarkModeToggle"
            >
              &#9728;
            </button>
            <label class="overlay-toggle">
              <input type="checkbox" />
              <span class="slider"></span>
            </label>
          </div>
        </nav>
      </div>
    </header>

    <!-- Main Content Section -->
    <main role="main" class="about-container">
      <section class="left-content">
        <!-- Article Section -->
        <section id="information">
          <h2>Project Name: Data Structure Library</h2>
          <hr />
          <h3>Overview</h3>
          <p>
            <span style="display: inline-block; width: 2em"></span>
            A library implementing common (and some uncommon but interesting)
            data structures in java. The idea here is largely to drill data
            structures in a way that will hopefully improve performance in
            technical interviews, in addition to testing with JUnit, which is a
            practice that I'm not going into this with any experience in.
          </p>
          <h3>List of Structures to be Implemented</h3>
          <ol>
            <li>Linear</li>
            <ol>
              <li>Dynamic array</li>
              <li>
                Doubly linked list (optionally circular, optionally singly
                linked)
              </li>
              <li>Array based stack</li>
              <li>Linked list-based stack</li>
              <li>Array-based circular queue</li>
              <li>Deque</li>
            </ol>
            <li>Hashing</li>
            <ol>
              <li>
                Open Addressing or Separate Chaining (differentiated with
                constructor arguments)
              </li>
            </ol>
            <li>Trees</li>
            <ol>
              <li>Binary search tree</li>
              <li>AVL tree</li>
              <li>Red-black tree</li>
              <li>B-tree</li>
              <li>Standard trie</li>
              <li>Compressed (radix) trie</li>
              <li>Treap</li>
            </ol>
            <li>Heaps</li>
            <ol>
              <li>Min heap</li>
              <li>Max heap</li>
              <li>Fibonacci heap</li>
            </ol>
            <li>Graphs</li>
            <ol>
              <li>Adjacency list</li>
              <li>Adjacency matrix</li>
              <li>Disjoint set</li>
            </ol>
            <li>Advanced</li>
            <ol>
              <li>Skip list</li>
              <li>Bloom filter</li>
              <li>Fenwick tree</li>
              <li>Segment tree</li>
              <li>Suffix tree</li>
              <li>Bloomier Filter</li>
              <li>Count Min Sketch</li>
              <li>Dancing Links</li>
              <li>HyperLogLog</li>
              <li>KD Tree</li>
              <li>Oct Tree</li>
              <li>Quad Tree</li>
              <li>Rope</li>
              <li>Splay Tree</li>
              <li>Van Emde Boas Tree</li>
            </ol>
          </ol>

          <h3>Linear</h3>
          <p>
            <span style="display: inline-block; width: 2em"></span>
            Array or LinkedList based structures: without an actual use case for
            this library, there wasn't a clearly superior choice between these
            two. I went with LinkedList based on the idea that it was more
            conceptually complex and would therefore be a better fit for what is
            really just a portfolio project. The conceptual complexity had
            already been handled by the LinkedList class itself though, so the
            Deque turned out to be a wrapper over that LinkedList class which
            was very quick to create.
          </p>

          <h3>Hashing</h3>
          <p>
            <span style="display: inline-block; width: 2em"></span> The first
            major change from my initial plan was to combine the Separate
            Chaining and Open Addressing implementations of a Hash Table into a
            single class which can differentiate between the two based on
            constructor arguments, but which creates just a simple linear
            probing hash table if nothing else is specified. <br /><br /><span
              style="display: inline-block; width: 2em"
            ></span>
            With the hash function, probing, and searching logic separated out
            to a utility HashFunctions file, the skeleton of this class came
            together quickly. A few put, delete, get, and clear methods. The
            biggest issue to manage was the array resizing logic in
            DynamicArray, which I built this on top of. I found myself having to
            independently track the resizing conditions in both this and the
            DynamicArray class, so that if the DynamicArray automatically
            resizes the hash table will rehash all its elements based on the new
            capacity. With that out of the way though, it was a fairly simple if
            verbose (because of the variety of options r/e collision resolution
            and probing).
          </p>

          <h3>Trees</h3>
          <p>
            <span style="display: inline-block; width: 2em"></span> After a long
            break (during which time i switched to Gentoo from Windows which was
            in retrospect nonsensical to the point of masochism), I returned
            with a commit for the first tree structure: BST.<br /><br /><span
              style="display: inline-block; width: 2em"
            ></span>
            The first few structures, BST and AVL, were mostly an exercise in
            recursion. While helpful, they became repetitive. I wondered if
            centralizing recursion logic in _TreeNode could work but found no
            obvious abstraction.<br /><br />
            <span style="display: inline-block; width: 2em"></span>
            Red-Black Trees were a departure, with iterative insertions and
            deletions replacing recursive methods, which were a headache to
            manage with parent pointers. I relied heavily on reference material
            -- this just did not come intuitively to me at all.<br /><br />
            <span style="display: inline-block; width: 2em"></span>
            BTrees were the hardest due to node merging. They're working, but
            barely. I'm hopeful practice will make it easier.<br /><br />
            <span style="display: inline-block; width: 2em"></span>
            Standard Tries were straightforward, so I added a good bit of extra
            functionality. Radix Tries were more challenging, but I got the core
            methods working. Merging and splitting nodes remains unintuitive,
            but my previous experience with BTree made this process smoother. I
            expect future operations like Fibonacci heaps and suffix trees will
            help refine my intuition over time.
          </p>

          <h3>Graphs and Heaps</h3>
          <p>
            <span style="display: inline-block; width: 2em"></span> There was
            really not a lot to these implementations. They all went up in a
            day, and I largely have a class I recently took (Mathematical
            Concepts of Computing, which heavily went over graph and set
            structures) to thank. Minor bump in the road with heap property
            violations, that was somewhat tricky with reordering after
            insertion, but it's all testing well so I'm happy to call it.
          </p>
          <h3>Advanced Structures</h3>
          <p>
            <span style="display: inline-block; width: 2em"></span>
            Honestly I had hoped I would have something more to report here.
            Truth is though, these were mechanical and deliberate. Unlike some
            other structures where there are a hundred good ways forward and I
            could really put myself into the code, there are just not as many
            changes to be made to these. Many rely on particular mathematical
            models and algorithms which are just that: algorithms. There's no
            personal flavor to my application of the quadratic equation vs
            someone elses, and there's nothing personal about my implementation
            of a bloom filter either.
            <br /><br /><span style="display: inline-block; width: 2em"></span>
            The whole experience was fast because me producing something that
            worked was essentially just active note-taking on my part.
            <br /><br /><span style="display: inline-block; width: 2em"></span>
            I abandoned some of the more carefully structured elements of the
            past structures, the primary way is being a touch lazier about
            javadoc comments and switching ot mostly using private inner classes
            rather than separate class files for utilities like nodes.
            <br /><br /><span style="display: inline-block; width: 2em"></span>
            One structure didn't make the cut at all: The Fusion Tree. It was
            already feeling like what I was doing was over the top when I was
            working on CountMinSketch, and by the time I got to fusion tree and
            some of those much much deeper bit manipulation moves, I found that
            I wasn't getting much out of the process and there was going to be
            precisely zero difference between the code I submitted and the code
            available online, so I called it there.
          </p>
          <h3>Benchmarking</h3>
          <p>
            <span style="display: inline-block; width: 2em"></span>
            The idea that I would benchmark differences in performance at all
            was an afterthought. I had already written the code and was just
            about to wrap up the project when I decided it would be neat to do a
            comparison. The expectation was that my functions would be hugely
            outperformed by the real deal implementations. A manic 6 hours
            later, I wrapped up a python script and ran it to find that the
            differences in almost every method were...too small to be detectable
            on matPlotLib output. A frenzied hour reading about z-score
            normalization later, I ran the updated script and found...basically
            the exact same thing. A calm 10 minutes later I ran a script that
            disregarded instances where the difference in method efficiency was
            zero or very near zero and found that there were a couple of
            implementations where my code marginally edges out the official
            "real versions"!
            <br /><br /><span style="display: inline-block; width: 2em"></span>
            More importantly, that last step of disregarding results at or near
            zero cut the number of bars on the output chart from about 200 to
            24. So the difference between my library and a real library is
            essentially negligible. Anyway, without further ado, here are the
            results. Blue bars indicate that my implementation was faster, red
            bars indicate that the real implementation was faster. Distance from
            the x-axis indicates the degree of difference. Open the image in a
            new tab to see it in full size.
          </p>
          <img
            src="images/testResults.png"
            alt="bar chart comparing execution time of various methods"
            class="library-pic"
            role="img"
          />
          <p>
            Anyone with a need for bizarre tree variants with fast insertion,
            let me know.
          </p>
        </section>
      </section>
    </main>

    <!-- Footer Section -->
    <footer role="contentinfo">
      <p>&copy; 2024 Nick Tagliamonte</p>
    </footer>

    <script src="js/mobileNavigation.js"></script>
    <script src="js/darkMode.js"></script>
  </body>
</html>
